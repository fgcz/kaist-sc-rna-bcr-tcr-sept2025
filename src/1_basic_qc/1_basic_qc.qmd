---
title: "Exercise #1: QC"
format:
  html:
    embed-resources: true
    toc: true
    toc-location: left
    toc-depth: 3
    title-block-banner: "#00A7FF"
filters:
  - flourish
css: report_assets/style.css
editor: visual
bibliography: report_assets/references.bib
---

## Learning outcomes

**After having completed this chapter you will be able to:**

-   Load single cell data into R
-   Explain the basic structure of a `Seurat` object and extract count data and metadata
-   Calculate and visualize quality measures based on:
    -   mitochondrial genes
    -   ribosomal genes
    -   hemoglobin genes
    -   relative gene expression
-   Interpret the above quality measures per cell
-   Perform cell filtering based on quality thresholds
-   Describe and perform standard procedures for normalization and scaling with the package `Seurat`
-   Select the most variable genes from a `Seurat` object for downstream analyses

## Loading scRNAseq data

The next step after the generation of the count matrices with `cellranger count`, is the data analysis. The `R` package `Seurat` is currently the most popular software to do this. To start working with `Seurat` you can load it into your environment like this:

```{r}
#| output: false
library(Seurat)
```

First, we need to extract the filtered feature-barcode matrices from your donor datasets:

```{r}
# Set up data directories
data_h5 <- c(
  "Donor1" = "~/work/5k-human-pbmc-3p-gem-x/Donor1/5k_Human_Donor1_PBMC_3p_gem-x_5k_Human_Donor1_PBMC_3p_gem-x_count_sample_filtered_feature_bc_matrix.h5",
  "Donor2" = "~/work/5k-human-pbmc-3p-gem-x/Donor2/5k_Human_Donor2_PBMC_3p_gem-x_5k_Human_Donor2_PBMC_3p_gem-x_count_sample_filtered_feature_bc_matrix.h5"
)
```

To run through a typical `Seurat` analysis, we will use the filtered_feature_bc_matrix directories. This directory is part of the output generated by `cellranger`. To load this data into R and generate a sparse matrix, run the following command:

```{r}
sparse_matrix_donor1 <- Seurat::Read10X_h5(filename = data_h5[["Donor1"]], use.names = TRUE, unique.features = TRUE)
sparse_matrix_donor2 <- Seurat::Read10X_h5(filename = data_h5[["Donor2"]], use.names = TRUE, unique.features = TRUE)

# Add sample prefixes to cell barcodes to make them unique
colnames(sparse_matrix_donor1) <- paste0("Donor1_", colnames(sparse_matrix_donor1))
colnames(sparse_matrix_donor2) <- paste0("Donor2_", colnames(sparse_matrix_donor2))

# Merge the matrices
# First, ensure both matrices have the same genes
common_genes <- intersect(rownames(sparse_matrix_donor1), rownames(sparse_matrix_donor2))
sparse_matrix_donor1 <- sparse_matrix_donor1[common_genes, ]
sparse_matrix_donor2 <- sparse_matrix_donor2[common_genes, ]

# Combine the matrices
sparse_matrix <- cbind(sparse_matrix_donor1, sparse_matrix_donor2)
rm(list="sparse_matrix_donor1", "sparse_matrix_donor2")
gc()
```

This imports a raw count matrix. Have a look at the counts of the first 30 cells of three genes by running:

```{r}
sparse_matrix[c("PECAM1", "CD8A", "TSPAN1"), 1:30]
```

You will see many dots (zeros) and a few integers representing the counts per gene per cell.

To generate a `Seurat` object, we will run `CreateSeuratObject`. Note that while creating the object, we already do some mild filtering; we only import genes that are expressed in at least 3 cells, and we only import cells that have at least 100 different genes expressed:

```{r}
scData <- Seurat::CreateSeuratObject(counts = sparse_matrix,
                                     project = "pbmmc",
                                     min.cells = 3,
                                     min.features = 100)
```

Check what's in the `scData` object, by typing `scData` in the R console. How many features are in there? And how many cells?

```{r}
scData
```

### The `Seurat` object

The `scData` object we have created has the class `Seurat`. The object contains multi-level slots and lists. Each `Seurat` object contains slots that store different types of information. You can get the information inside a slot with `@`, in the same way as you would use the `$` for lists (e.g. `scData@meta.data` will return a data frame with information on each cell).

In addition to the original count table, the `Seurat` object can store a lot of information that is generated during your analysis, like results of a normalization (`@assays$RNA@data`) a PCA or UMAP (`@reductions`) and the clustering (`@graphs`). It also tracks all the commands that have been used to generate the object in its current state (`@commands`). Therefore, while going through the analysis steps, the same object gets more and more of its slots filled. Because most `Seurat` functions return the input object + adjusted slots, we can use this syntax:

```         
seurat_object <- Seurat::function(seurat_object)
```

So, the function takes an object as input and we assign it to an object with the same name. Meaning that we overwrite the object used as input.

Have a look at the `scData` object by running `View(scData)`. What is in there? What is stored in `@active.ident`?

Have a look at the `data.frame` stored at `scData@meta.data` what kind of information is in there?

```{r}
head(scData@meta.data)
tail(scData@meta.data)
```

Luckily, usually you do not have to dive into this structure to retrieve information. For example, information in the slot `@meta.data` can be retrieved and set by using `$` or `[[]]`.

Generate a histogram of the column `nCount_RNA` at `scData@meta.data`, with the base function `hist`:

```{r}
hist(scData$nCount_RNA)
```

There are also built-in functions to plot data from `Seurat` object, for example `FeatureScatter`. This function enables you easily draw a scatterplot from a `Seurat` object:

```{r}
Seurat::FeatureScatter(scData, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
```

### Visualizing QC per cell and gene

While generating the `Seurat` object, there were already some quality measures calculated for each cell, namely the total UMI counts per cell (`nCount_RNA`) and the total number of detected features per cell (`nFeature_RNA`). We can plot those in a violin plot and evaluate their distribution per sample:

```{r}
Seurat::VlnPlot(scData, features = c("nCount_RNA",
                                     "nFeature_RNA"))
```

You can see that there is quite a wide range for both. A cell with low number of detected features or counts might not give you a lot of information, while a high number of detected features/counts might point to doublets.

Single cells have often undergone sampling and/or dissociation and/or sorting. Therefore, there are often cells and genes in your dataset that cause variation due to technical reasons. In the following steps, we will visualize those and make decisions on whether or not to remove cells or genes with extreme values.

We will start with calculating the percentage of counts coming from transcript types:

-   **Mitochondrial genes**: If a cell membrane is damaged, it looses free RNA quicker compared to mitochondrial RNA, because the latter is part of the mitochondrion. A high relative amount of mitochondrial counts can therefore point to damaged cells.
-   **Ribosomal genes**: Are not rRNA (ribosomal RNA) but is mRNA that code for ribosomal proteins. They do not point to specific issues, but it can be good to have a look at their relative abundance. They can have biological relevance.
-   **Hemoglobin genes**: these transcripts are very abundant in erythrocytes. Depending on your application, you can expect 'contamination' of erythrocytes and select against it.

In order to have an idea about the relative counts of these type of genes in our dataset, we can calculate their expression as relative counts in each cell. We do that by selecting genes based on patterns (e.g. `^MT-` matches with all gene names starting with `MT`, i.e. mitochondrial genes):

```{r}
# mitochondrial genes
scData <- Seurat::PercentageFeatureSet(scData, 
                                       pattern = "^MT-", 
                                       col.name = "percent.mito")

# ribosomal genes
scData <- Seurat::PercentageFeatureSet(scData, 
                                       pattern = "^RP[SL]",
                                       col.name = "percent.ribo")

# hemoglobin genes (but not HBP)
scData <- Seurat::PercentageFeatureSet(scData,
                                       pattern = "^HB[^(P)]",
                                       col.name = "percent.globin")
```

Check out the metadata data frame at `scData@meta.data`. What has changed?

```{r}
head(scData@meta.data)
```

The function `PercentageFeatureSet` adds a column to `meta.data`, specifying the percentage of counts for the specified gene sets.

Now we can plot the distribution of these percentages in a violin plot:

```{r}
Seurat::VlnPlot(scData, features = c("percent.mito",
                                     "percent.ribo",
                                     "percent.globin"))
```

Let's have a look at the correlation between mitochondrisl and ribosomal percentages:

```{r}
Seurat::FeatureScatter(scData, 
                       feature1 = "percent.globin", 
                       feature2 = "percent.ribo")
```

We can also evaluate the relative expression of other genes in our dataset, for example, the ones that are most highly expressed. Some very highly expressed genes might point to a technical cause, and we might consider to remove them. Below you will find a simple function to generate a boxplot of relative counts per gene per cell:

```{r}
library(ggplot2)
library(Matrix)
library(Seurat)

most_expressed_boxplot <- function(object, ngenes = 20){
  
  cts <- Seurat::GetAssayData(object, assay = "RNA", layer = "counts")
  
  cell_totals <- Matrix::colSums(cts)
  
  # Calculate mean percentage for each gene across all cells
  # This avoids creating the full percentage matrix
  gene_mean_pct <- Matrix::rowSums(cts) / sum(cell_totals) * 100
  
  most_expressed <- order(gene_mean_pct, decreasing = TRUE)[1:ngenes]
  top_genes <- rownames(cts)[most_expressed]
  
  top_gene_matrix <- as.matrix(cts[most_expressed, ])
  
  top_gene_pct <- sweep(top_gene_matrix, 2, cell_totals, "/") * 100
  
  most_exp_df <- data.frame(
    perc_total = as.vector(top_gene_pct),
    gene = rep(top_genes, each = ncol(top_gene_pct))
  )
  
  most_exp_df$gene <- factor(most_exp_df$gene, levels = rev(top_genes))
  
  boxplot <- ggplot(most_exp_df, aes(x = gene, y = perc_total)) +
    geom_boxplot() +
    coord_flip() +
    labs(x = "Gene", y = "Percentage of total counts")
  
  return(boxplot)
}

most_expressed_boxplot(scData, 20)
```

### Cell filtering

Based on the QC process we went through we can come to the following conclusions:

-   The data look very clean. There are a small number of outliers.
-   There may be some cells with hemoglobin and low ribosomal counts, which could be erythrocytes. Though they make up a tiny fraction of the data, we should remove them.
-   There are some cells with a very low and very high number of features. These might point to non-informative cells and doublets respectively
-   Some highly expressed genes like MALAT1 might be present

A sensible decision would be to do mild filtering on the number of features per cell and mitochondrial counts. We can leave possible erythrocytes in for now, and see where they end up later during the dimensionality reduction.

Here we filter out cells with high mitochondrial content and extreme feature counts:

```{r}
nFeatureMin <- 1000
nFeatureMax <- 5500
percentMitoMax <- 10

Seurat::VlnPlot(scData, features = "nFeature_RNA")  + 
  geom_hline(yintercept = nFeatureMin, linetype = "dashed", color = "red") +
  geom_hline(yintercept = nFeatureMax, linetype = "dashed", color = "red")

Seurat::VlnPlot(scData, features = "percent.mito") +
  geom_hline(yintercept = percentMitoMax, linetype = "dashed", color = "red")

scData <- subset(scData, subset = nFeature_RNA > nFeatureMin &
                 nFeature_RNA < nFeatureMax &
                 percent.mito < percentMitoMax)
```

To evaluate this did the trick we can visualize those parameters again in a violin plot:

```{r}
Seurat::VlnPlot(scData, features = c("nFeature_RNA",
                                     "percent.mito"))
```

## Normalization

After removing unwanted cells from the dataset, the next step is to normalize the data. By default, Seurat employs a global-scaling normalization method `"LogNormalize"` that normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result. Normalized values are stored in the "RNA" assay (as item of the `@assay` slot) of the scData object.

```{r}
scData <- Seurat::NormalizeData(scData,
                                normalization.method = "LogNormalize",
                                scale.factor = 10000)
```

You can check out some assay data with:

```{r}
Seurat::GetAssayData(scData)[1:10,1:10]  
```

## Variable features

We next calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e, they are highly expressed in some cells, and lowly expressed in others). Focusing on these genes in downstream analysis helps to highlight biological signal in single-cell datasets. The procedure in Seurat models the mean-variance relationship inherent in single-cell data, and is implemented in the `FindVariableFeatures()` function. By default, 2,000 genes (features) per dataset are returned and these will be used in downstream analysis, like PCA.

```{r}
scData <- Seurat::FindVariableFeatures(scData,
                                       selection.method = "vst",
                                       nfeatures = 2000)
```

Let's have a look at the 10 most variable genes:

```{r}
# Identify the 10 most highly variable genes
top10 <- head(Seurat::VariableFeatures(scData), 10)
top10
```

We can plot them in a nicely labeled scatterplot:

```{r}
vf_plot <- Seurat::VariableFeaturePlot(scData)
Seurat::LabelPoints(plot = vf_plot,
                    points = top10, repel = TRUE)
```

You can see the most highly variable genes in your dataset.

## Scaling

Next, we apply scaling, a linear transformation that is a standard pre-processing step prior to dimensional reduction techniques like PCA. The `ScaleData()` function

1.  shifts the expression of each gene, so that the mean expression across cells is 0
2.  scales the expression of each gene, so that the variance across cells is 1

This step gives equal weight in downstream analyses, so that highly-expressed genes do not dominate. The results of this are stored in `scData$RNA@scale.data`

```{r}
scData <- Seurat::ScaleData(scData)
```

Save the dataset for use in Part 2:

```{r}
saveRDS(scData, "../scData_part1.rds")
```
